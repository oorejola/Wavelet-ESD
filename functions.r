# Oliver Orejola
# Created:10/24/21
# 
#------------------------- [ Libraries ]----------------------------
library(somebm)
library(wavelets)
library(MASS)
library(diptest)
#------------------------- [ Functions ]----------------------------

coordinate_matrix <- function(n){
  mat <- c()
  for(i in 1:n){
    x <- rnorm(n)
    col <- x/sqrt(sum(x^2)) 
    mat <- append(mat,col)
  }
  return(matrix(mat, n, n,byrow = FALSE))
}

probabilistic_wavelet_sample_covariances<- function(level,scales,dimension,Hursts, mixed = FALSE){
  N = 2^level #Path size
  #n_j = N/(2^scale)
  P <- coordinate_matrix(dimension)
  wavelet_list <- list()
  #Create blank list of NA from which we will construct List of Vectors
  for(j in scales){wavelet_list <- append(wavelet_list, c(NA))}
  for(p in 1:dimension){
    H <- sample(Hursts,1)
    fractional_brownian <-  N^H*fbm(hurst = H, n = N)
    wavelet_transform <- dwt(fractional_brownian, filter = "d4", n.levels = level, boundary = "reflection")
    i = 1
    for(j in scales){ 
      wavelet_coefficients <- unlist(wavelet_transform@W[j+1])
      wavelet_list[[i]] <- append(wavelet_list[[i]] ,wavelet_coefficients)
      i <- i+1
    }
  }
  # Remove NA generated by initiation of list of blank vectors
  for(i in 1:length(wavelet_list)){wavelet_list[[i]] <-wavelet_list[[i]][!is.na(wavelet_list[[i]])]}
  
  i=1
  for(j in scales){
    effective_sample_size = 2^(level-j)
    wavelet_mat <- matrix(wavelet_list[[i]], effective_sample_size, p,byrow = FALSE)  # convert vectors into matrices 
    if(mixed == TRUE){ 
      mixed_wavlet_mat <- wavelet_mat %*% t(P)
      mixed_wavlet_product <- crossprod(mixed_wavlet_mat)
      eigenvalues <- eigen(1/effective_sample_size *mixed_wavlet_product)$values #add list of eigenvalues
    }
    else{
      wavelet_product <-  crossprod(wavelet_mat)
      eigenvalues <- eigen(1/effective_sample_size *wavelet_product)$values
    }
    wavelet_list[[i]]  <- eigenvalues
    i=i+1
  }
  return(as.data.frame(wavelet_list,col.names =  scales))
}

wavelet_regression_estimator <- function(level,j1, window_size, dimension,Hursts, mixed = FALSE){
  
  scale_max <- level-log(dimension,base=2)
  log_wavelet_eigevalues <- log(probabilistic_wavelet_sample_covariances(level,c(j1:scale_max),dimension,Hursts, mixed),base=2)
  estimate<-c()
  index<-1
  init_j2 <- j1 + window_size-1
  
  for( j2 in c(init_j2:scale_max)){
    L = length(c(j1:j2))
    X <- matrix(c(c(j1:j2),rep(1,L)),2,L,byrow=TRUE)
    weights <- ginv(X)%*%c(1,0)
    delta <- rep(0,dimension)
    l <-1
    for(j in c(j1:j2)){
    delta <- delta + weights[l]*log_wavelet_eigevalues[l]
    l <- l + 1
    }
    estimate[index]<- delta
    index <- index + 1
  }
  return(estimate)
}

#data_test_1 <- log2(probabilistic_wavelet_sampe_covariances(16,c(5:7),2^4,c(0.2,0.5),mixed = TRUE))



monte_carlo_probability_of_rejection <- function(runs,dip_test_significance,level,j1, window_size, dimension,Hursts, mixed = FALSE){
  scale_max <- level-log(dimension,base=2)
  init_j2 <- j1 + window_size-1
  number_of_estimates <- length(c(init_j2:scale_max))
  counts <-  rep(0,number_of_estimates)
  for(i in 1:runs){
    if(i %% 100 ==0){
      print(paste("run :", i))
      print(counts)
    }
    estimate <- wavelet_regression_estimator(level,j1,window_size,dimension,Hursts, mixed)
    for( j in c(1: number_of_estimates)){
    
      pvalue<-dip.test(unlist(estimate[j]))$p.value
      if( pvalue<= dip_test_significance){
      counts[j]  <- counts[j] + 1
      #print("reject")
     }
    }
  }
  proportion_of_rejections <- counts/runs
  return(proportion_of_rejections)
}


#---------------------- [Rejection Analysis ]----------------------
runs = 1000
sig_levels <-  seq(0.05,0.95,by = 0.05)
alphas <-list()
index <- 1

for(sig in sig_levels){
  test <- monte_carlo_probability_of_rejection(runs,sig,12,2,3,2^6,c(0.5))
  print(paste("dip_test_significance:" ,sig))
  print(test)
  alphas[[index]]<- test
  index <- index + 1 
}
alphas <- as.data.frame(alphas,col.names = sig_levels)
