# Oliver Orejola
# Created: 9/27/21
# 
#------------------------- [ Libraries ]----------------------------
library(somebm)
library(wavelets)
library(diptest)
library(MASS)
#------------------------- [ Functions ]----------------------------
coordinate_matrix <- function(n){
  mat <- c()
  for(i in 1:n){
    x <- rnorm(n)
    col <- x/sqrt(sum(x^2)) 
    mat <- append(mat,col)
  }
  return(matrix(mat, n, n,byrow = FALSE))
}

low_dim_wavelet_sampe_covariances<- function(level,scales,Hursts, mixed = FALSE){
  N = 2^level #Path size
  #n_j = N/(2^scale)
  p = length(Hursts)
  P <- coordinate_matrix(p)
  wavelet_list <- list()
  for(j in scales){
    wavelet_list <- append(wavelet_list, c(NA))
  }
  for(H in Hursts){
    fractional_brownian <-  N^H*fbm(hurst = H, n = N) 
    wavelet_transform <- dwt(fractional_brownian, filter = "d2", n.levels = level, boundary = "reflection")
    i = 1
    for(j in scales){  
      wavelet_list[[i]] <- append(wavelet_list[[i]] ,unlist(wavelet_transform@W[j]))
      i <- i+1
    }
  }
  # Remove NA generated by initiation of list of blank vectors
  for(i in 1:length(wavelet_list)){
    wavelet_list[[i]] <-wavelet_list[[i]][!is.na(wavelet_list[[i]])]
  }
  
  i=1
  for(j in scales){
    effective_sample_size = N/(2^j) #
    wavelet_mat <- matrix(wavelet_list[[i]], effective_sample_size, p,byrow = FALSE)  # convert vectors into matrices 
    if(mixed == TRUE){ 
      mixed_wavlet_mat <- wavelet_mat %*% t(P)
      mixed_wavlet_product <- crossprod(mixed_wavlet_mat)
      eigenvalues <- eigen(1/effective_sample_size *mixed_wavlet_product)$values #add list of eigenvalues
    }
    else{
      wavelet_product <-  crossprod(wavelet_mat)
      eigenvalues <- eigen(1/effective_sample_size *wavelet_product)$values
    }
    wavelet_list[[i]]  <- eigenvalues
    i=i+1
  }
  return(wavelet_list)
}



#------[ Simulations and Data generation ]----------
set.seed(1000)
#---------- MEAN SQUARED DIFFERENCE 
max_level = 15
min_level = 11
Hurst_1 = 0.25
Hurst_2 = 0.75

runs = 1000

mc_estimate_MSD_1 <- c()
mc_estimate_MSD_2 <- c()
mc_std_MSD_1 <- c()
mc_std_MSD_2 <- c()
RMSE <- c()
j1 <- 5
j2 <- 7
for(level in min_level:max_level){
  
  pathsize = 2^level
  regression_coefficient_avg_1 <- c()
  regression_coefficient_avg_2 <- c()
  for(r in 1:runs){
    FBM_1 <- pathsize^Hurst_1*fbm(Hurst_1, pathsize)
    FBM_2 <- pathsize^Hurst_2*fbm(Hurst_2, pathsize)
    MSD_data_1 <- c()
    MSD_data_2 <- c()
    for(j in c(j1:j2)){
      MSD_1 <- mean(diff(FBM_1,2^j)^2)
      MSD_2 <- mean(diff(FBM_2,2^j)^2)
      MSD_data_1 <- append(MSD_data_1,MSD_1)
      MSD_data_2 <- append(MSD_data_2,MSD_2)
    }
    Linear_Model_1<-lm(log(MSD_data_1 ,base=2)~c(j1:j2))
    Linear_Model_2<-lm(log(MSD_data_2 ,base=2)~c(j1:j2))
    regression_coefficient_avg_1 <- append(regression_coefficient_avg_1,summary(Linear_Model_1)$coefficients[2,1])
    regression_coefficient_avg_2 <- append(regression_coefficient_avg_2,summary(Linear_Model_2)$coefficients[2,1])
  }
  mc_estimate_1<- mean(regression_coefficient_avg_1)
  MSE <- mean((regression_coefficient_avg_1-2*Hurst_1)**2)
  RMSE <- append(RMSE, sqrt(MSE))
  mc_std_1 <-sd(regression_coefficient_avg_1)
  mc_estimate_2<- mean(regression_coefficient_avg_2)
  mc_std_2 <-sd(regression_coefficient_avg_2)
  mc_std_MSD_1 <- append(mc_std_MSD_1,mc_std_1)
  mc_std_MSD_2 <- append(mc_std_MSD_2,mc_std_2)
  mc_estimate_MSD_1 <- append(mc_estimate_MSD_1,mc_estimate_1)
  mc_estimate_MSD_2 <- append(mc_estimate_MSD_2,mc_estimate_2)
  j1 <- j1 + 1
  j2 <- j2 + 1
}
mc_estimate_MSD_1 <- (mc_estimate_MSD_1)*0.5
mc_estimate_MSD_2 <- (mc_estimate_MSD_2)*0.5
 
par(mfrow=c(3,1))

plot(c(min_level:max_level),mc_estimate_MSD_1 , type = "l"
     , xlab = "path size"
     , ylab = "angular coefficent"
     , main = paste(" regression coefficients for logMSD vs Path size, Hurst = ", Hurst_1))
#plot(c(min_level:max_level),mc_estimate_MSD_2, type = "l" , xlab = "path size" , ylab = "angular coefficent" , main = paste("regression coefficients for logMSD vs Path size, Hurst = ", Hurst_2))

plot(c(min_level:max_level),RMSE, type = "o"
     , xlab = "pathsize"
     , ylab = "RMSE"
     , main = paste("MC runs = ", runs))

plot(c(min_level:max_level),mc_std_MSD_1, type = "o"
     , xlab = "pathsize"
     , ylab = "MC std"
     , main = paste("MC runs = ", runs))


#-----------------Regression -------------------------


Hurst_1 = 0.25
#Hurst_2 = 0.75
min_level = 11 #range of octaves to simulate over
max_level = 15


data_1 <- c()
data_RMSE <- c()
data_sd <- c()
#data_2 <- c()
runs = 1000 #number of MC runs

j1 <- 5
j2 <- 7
seedcounter <-1
for(level in min_level:max_level){
  mc_delta_1 <- c()
  data_SE <- c()
  l = j2-j1+1
  X <- matrix(c(c(j1:j2),rep(1,l)),2,l,byrow=TRUE)
  weights <- ginv(X)%*%c(1,0)
  #null_space <- Null(t(X))
  for(r in 1:runs){
    wavelet_eigen_1 <- low_dim_wavelet_sampe_covariances(level,c(j1:j2),Hurst_1)
    delta_1 <- 0
    for(i in 1:l){
      delta_1<- delta_1 + weights[i]*log(wavelet_eigen_1[[i]],base=2)
    }
    data_SE <- append(data_SE, (delta_1 - (2*Hurst_1 + 1))**2)
    mc_delta_1 <-append(mc_delta_1,delta_1)
  }
  rescaled_delta <- (mc_delta_1 - rep(1,length(mc_delta_1)))*0.5
  data_1 <- append(data_1,mean(rescaled_delta))
  data_sd <- append(data_sd, sd(rescaled_delta ))
  data_RMSE <- append(data_RMSE,sqrt(mean(data_SE)))
  j1 <- j1 + 1
  j2 <- j2 + 1
}

par(mfrow=c(3,1))

plot(c(min_level:max_level),data_1, type = "l"
     , xlab = "path size"
     , ylab = "delta"
     , main = paste("rescaled Delta Estimator vs Path size, Hurst = ", Hurst_1))
plot(c(min_level:max_level),data_RMSE, type = "o"
     , xlab = "path size"
     , ylab = "RMSE"
     , main = paste("runs  = ", runs))

plot(c(min_level:max_level),data_sd, type = "o"
     , xlab = "path size"
     , ylab = "MC std"
     , main = paste("runs  = ", runs))


