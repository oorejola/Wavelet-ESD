# Oliver Orejola
# Created: 9/27/21
# 
#------------------------- [ Libraries ]----------------------------
library(somebm)
library(wavelets)
library(MASS)

#------------------------- [ Functions ]----------------------------
coordinate_matrix <- function(n){
  mat <- c()
  for(i in 1:n){
    x <- rnorm(n)
    col <- x/sqrt(sum(x^2)) 
    mat <- append(mat,col)
  }
  return(matrix(mat, n, n,byrow = FALSE))
}


probabilistic_wavelet_sampe_covariances<- function(level,scales,dimension,Hursts, mixed = FALSE){
  N = 2^level #Path size
  #n_j = N/(2^scale)
  p = length(Hursts)
  P <- coordinate_matrix(p)
  wavelet_list <- list()
  #Create blank list of NA from which we will construct List of Vectors
  for(j in scales){wavelet_list <- append(wavelet_list, c(NA))}
  for(p in 1:dimension){
    H <- sample(Hursts,1)
    fractional_brownian <-  N^H*fbm(hurst = H, n = N)
    wavelet_transform <- dwt(fractional_brownian, filter = "d4", n.levels = level, boundary = "reflection")
    i = 1
    for(j in scales){ 
      wavelet_coefficients <- unlist(wavelet_transform@W[j+1])
      wavelet_list[[i]] <- append(wavelet_list[[i]] ,wavelet_coefficients)
      i <- i+1
    }
  }
  # Remove NA generated by initiation of list of blank vectors
  for(i in 1:length(wavelet_list)){wavelet_list[[i]] <-wavelet_list[[i]][!is.na(wavelet_list[[i]])]}
  
  i=1
  for(j in scales){
    effective_sample_size = 2^(level-j)
    wavelet_mat <- matrix(wavelet_list[[i]], effective_sample_size, p,byrow = FALSE)  # convert vectors into matrices 
    if(mixed == TRUE){ 
      mixed_wavlet_mat <- wavelet_mat %*% t(P)
      mixed_wavlet_product <- crossprod(mixed_wavlet_mat)
      eigenvalues <- eigen(1/effective_sample_size *mixed_wavlet_product)$values #add list of eigenvalues
    }
    else{
      wavelet_product <-  crossprod(wavelet_mat)
      eigenvalues <- eigen(1/effective_sample_size *wavelet_product)$values
    }
    wavelet_list[[i]]  <- eigenvalues
    i=i+1
  }
  return(wavelet_list)
}

delta_estimator_multivariate <- function(hurst,min_level,max_level, dimension, runs){
  data <- list() #Initialize blank lists
  data_sd <- list()
  data_RMSE <- list()
  j1 <- 3 #Fixed at 3 to match paper
  level_index=1
  for(level in min_level:max_level){
    mc_delta<- list()
    data_SE <- list()
    j2 <- level -log(dimension,base=2) # set j2 to  log_2(path_size) - number of vanishing moments
    l = j2-j1+1
    X <- matrix(c(c(j1:j2),rep(1,l)),2,l,byrow=TRUE)
    weights <- ginv(X)%*%c(1,0)
    for(r in 1:runs){
      wavelet_eigen <- probabilistic_wavelet_sampe_covariances(level,c(j1:j2),dimension,hurst)
      delta <- rep(0,length(hurst))
      for(i in 1:l){
        sorted_eigen_values <-sort(wavelet_eigen[[i]])
        delta<- delta + weights[i]*log(wavelet_eigen[[i]],base=2)
      }
      mc_delta[[r]] <- delta 
      data_SE[[r]] <- (delta - (2*hurst + 1))**2
      
    }
    mc_delta <- as.data.frame(mc_delta)
    data_SE <- as.data.frame(data_SE)
    data[[level_index]]<- apply(mc_delta,1,mean)
    data_sd[[level_index]]<- apply(mc_delta,1,sd)*0.5
    data_RMSE[[level_index]]<- sqrt(apply(data_SE,1,mean))
    level_index<- level_index+1
  }
  return(list(data,data_sd,data_RMSE))
}





# Compare log(wavelet_eigenvalues) with that of the regression estimate via delta estimator
level <- 16
dimension <- 2^6
j2 <- level-log(dimension,base=2)
j1 <- 4

par(mfrow=c(1,2))
eigenvalues <- log(unlist(probabilistic_wavelet_sampe_covariances(level,j2,dimension,c(0.2,0.8))),base=2)/j2*0.5 - 0.5
hist(eigenvalues , breaks = 32,
     main = paste("log_2(N)=",level, " p=",dimension," Scale = ",j2),
     xlab = "log(wavelet_eigenvalues)"
     )
abline(v=0.2, col="blue" ) 
#abline(v=0.5, col="blue")
abline(v=0.8, col="blue")


delta<- delta_estimator_multivariate( c(0.2,0.8), level,level,dimension,1)
delta_eigenvalues <- delta[[1]][[1]]*0.5 - 0.5
hist(delta_eigenvalues , breaks = 32,
     main = paste("log_2(N)=",level," p=",dimension, "j1 = ", j1, "j2 = ", j2),
     xlab = "regression_wavelet_eigenvalues")
abline(v=0.2, col="blue" )
#abline(v=0.5, col="blue")
abline(v=0.8, col="blue")



par(mfrow=c(2,3))
level <- 17
dimension <- 2^6
j2 <- level-log(dimension,base=2)
j1 <- 5
data_eigenvalues <- c()
i=1
Hurst = c(0.6,0.95)
wavelet_eigenvalues <-probabilistic_wavelet_sampe_covariances(level,c(j1:j2),dimension,Hurst)

for(j in j1:j2){
  
  eigenvalues<-log(unlist(wavelet_eigenvalues[[i]]),base=2)/j*0.5-0.5
  hist(eigenvalues , breaks = 32,
      xlim = c(-0.5,1),
      main = paste("log_2(N)=",level, " p=",dimension," Scale = ",j),
      xlab = "log(wavelet_eigenvalues)"
  )
  data_eigenvalues[[i]]<-eigenvalues
  i <- i+1
  abline(v=Hurst[1], col="blue" ) 
  #abline(v=0.5, col="blue")
  abline(v=Hurst[2], col="blue")
}


data <- as.data.frame(data_eigenvalues,col.names = c(j1:j2))


par(mfrow=c(1,1))

plot(c(j1:j2),unlist(data[1,]), type = 'l', col = 2,ylim = c(-0.5,1)
     ,ylab = "log_2(eigenvalues)/j*0.5-0.5"
     ,xlab = "j = scale "
     ,main = paste("log(wavelet eigenvalues), log_2(pathsize)=", level, ",p=",dimension ))
abline(h=Hurst[1], col="blue" ) 
#abline(v=0.5, col="blue")
abline(h=Hurst[2], col="blue")
for(i in c(2:dimension)){
  lines(c(j1:j2),unlist(data[i,]))
}




#######33-----------------

level <- 13
dimension <- 2^6
scale_max <- level-log(dimension,base=2)
scale_min <- 2
window_size <-3
hurst = c(0.6,0.95)
#hurst = c(0.3, 0.4, 0.5,0.7,0.8,0.9)
wavelet_eigenvalues <-as.data.frame(probabilistic_wavelet_sampe_covariances(level,c(scale_min:scale_max),dimension,hurst),col.names =c(scale_min:scale_max))

log_wavelet_eigevalues <- log2(wavelet_eigenvalues)




scale = scale_min 
j1 = scale
i = 1
data<-c()
while(scale + window_size-1 < level - log2(dimension)){
  #j1 <- scale
  j2 <- scale + window_size-1
  L = j2-j1+1
  X <- matrix(c(c(j1:j2),rep(1,L)),2,L,byrow=TRUE)
  #print(X)
  weights <- ginv(X)%*%c(1,0)
  
  l <-1
  delta <- rep(0,dimension)
  for(j in c(j1:j2)){
    delta <- delta + weights[l]*log_wavelet_eigevalues[l]
    l<-l+1
  }
  #print(delta)
  data[i]<-delta
  scale <- scale + 1
  i<- i+1
}


L <- length(data)
  
par(mfrow=c(2,L)) 

i=0
for(dat in data){
  #j1 = scale_min + i
  j2 = j1 + window_size +i
  hist(dat*0.5-0.5,breaks = 32,
       xlim = c(0,1),
       xlab = "regression eigenvalues",
       main = paste("log_2(N)=",level, " p=",dimension," j1= ",j1,"j2=",j2))
  for(hur in hurst){
    abline(v=hur, col="blue" ) 
  }
  i<-i+1
}


data <- as.data.frame(data,col.names = c(1:L))

par(mfrow=c(1,1))

init <- scale_min+window_size-1
fin <- init + L-1
plot(c(init:fin),unlist(data[1,])*0.5-0.5, type = 'l', col = 2,ylim = c(-.25,1)
     ,ylab = "regression eigenvalues"
     ,xlab = "j2  "
     ,main = paste(" log_2(pathsize)=", level, ",p=",dimension ))
for(hur in hurst){
  abline(h=hur, col="blue" ) 
}
for(i in c(2:dimension)){
  lines(c(init:fin),unlist(data[i,])*0.5-0.5)
}




### Sliding window
### Sliding window aproach is very bad
par(mfrow=c(2,3))
level <- 16
dimension <- 2^6
scale_max <- level-log(dimension,base=2)
scale_min <- 2
window_size <-3

wavelet_eigenvalues <-as.data.frame(probabilistic_wavelet_sampe_covariances(level,c(scale_min:scale_max),dimension,c(0.2,0.8)),col.names =c(scale_min:scale_max))

log_wavelet_eigevalues <- log2(wavelet_eigenvalues)




scale = scale_min 
j1 = scale
i = 1
data<-c()
while(scale + window_size-1 < level - log2(dimension)){
  j1 <- scale
  j2 <- scale + window_size-1
  L = j2-j1+1
  X <- matrix(c(c(j1:j2),rep(1,L)),2,L,byrow=TRUE)
  print(X)
  weights <- ginv(X)%*%c(1,0)
  
  l <-1
  delta <- rep(0,dimension)
  for(j in c(j1:j2)){
    print(paste(j,l))
    scale_index <-  j - scale_min +1
    delta <- delta + weights[l]*log_wavelet_eigevalues[scale_index]
    l<-l+1
  }
  
  data[i]<-delta
  scale <- scale + 1
  i<- i+1
}

i=0
for(dat in data){
  j1 = scale_min + i
  j2 = j1 + window_size +i
  hist(dat*0.5-0.5,breaks = 32,
       xlim = c(0,1),
       xlab = "regression eigenvalues",
       main = paste("log_2(N)=",level, " p=",dimension," j1= ",j1,"j2=",j2))
  abline(v=0.2, col="blue" ) 
  abline(v=0.8, col="blue")
  i<-i+1
}


data <- as.data.frame(data,col.names = c(1:6))

par(mfrow=c(1,1))

plot(c(1:6),unlist(data[1,])*0.5-0.5, type = 'l', col = 2,ylim = c(-0.5,1)
     ,ylab = "log_2(eigenvalues)/j*0.5-0.5"
     ,xlab = "j = scale "
     ,main = paste("log(wavelet eigenvalues), log_2(pathsize)=", level, ",p=",dimension ))
abline(h=0.2, col="blue" ) 
#abline(v=0.5, col="blue")
abline(h=0.8, col="blue")
for(i in c(2:dimension)){
  lines(c(1:6),unlist(data[i,])*0.5-0.5)
}


