# Oliver Orejola
# Created: 9/27/21
# 
#------------------------- [ Libraries ]----------------------------
library(somebm)
library(wavelets)
library(diptest)
library(MASS)
#------------------------- [ Functions ]----------------------------
coordinate_matrix <- function(n){
  mat <- c()
  for(i in 1:n){
    x <- rnorm(n)
    col <- x/sqrt(sum(x^2)) 
    mat <- append(mat,col)
  }
  return(matrix(mat, n, n,byrow = FALSE))
}

low_dim_wavelet_sampe_covariances<- function(level,scales,Hursts, mixed = FALSE){
  N = 2^level #Path size
  #n_j = N/(2^scale)
  p = length(Hursts)
  P <- coordinate_matrix(p)
  wavelet_list <- list()
  for(j in scales){
    wavelet_list <- append(wavelet_list, c(NA))
  }
  for(H in Hursts){
    fractional_brownian <-  N^H*fbm(hurst = H, n = N) 
    wavelet_transform <- dwt(fractional_brownian, filter = "d2", n.levels = level, boundary = "reflection")
    i = 1
    for(j in scales){  
      wavelet_list[[i]] <- append(wavelet_list[[i]] ,unlist(wavelet_transform@W[j]))
      i <- i+1
    }
  }
  # Remove NA generated by initiation of list of blank vectors
  for(i in 1:length(wavelet_list)){
    wavelet_list[[i]] <-wavelet_list[[i]][!is.na(wavelet_list[[i]])]
  }
  
  i=1
  for(j in scales){
    effective_sample_size = N/(2^j) #
    wavelet_mat <- matrix(wavelet_list[[i]], effective_sample_size, p,byrow = FALSE)  # convert vectors into matrices 
    if(mixed == TRUE){ 
      mixed_wavlet_mat <- wavelet_mat %*% t(P)
      mixed_wavlet_product <- crossprod(mixed_wavlet_mat)
      eigenvalues <- eigen(1/effective_sample_size *mixed_wavlet_product)$values #add list of eigenvalues
    }
    else{
      wavelet_product <-  crossprod(wavelet_mat)
      eigenvalues <- eigen(1/effective_sample_size *wavelet_product)$values
    }
    wavelet_list[[i]]  <- eigenvalues
    i=i+1
  }
  return(wavelet_list)
}



#------[ Simulations and Data generation ]----------
set.seed(1000)
#---------- MEAN SQUARED DIFFERENCE 
max_level = 17
min_level = 11
Hurst_1 = 0.25
Hurst_2 = 0.75

runs = 1000

data_MSD_1 <- c()
data_MSD_2 <- c()
j1 <- 5
j2 <- 7
for(level in min_level:max_level){
  
  pathsize = 2^level
  regression_coefficient_avg_1 <-0
  regression_coefficient_avg_2 <-0
  for(r in 1:runs){
    FBM_1 <- pathsize^Hurst_1*fbm(Hurst_1, pathsize)
    FBM_2 <- pathsize^Hurst_2*fbm(Hurst_2, pathsize)
    MSD_data_1 <- c()
    MSD_data_2 <- c()
    for(j in c(j1:j2)){
      MSD_1 <- mean(diff(FBM_1,2^j)^2)
      MSD_2 <- mean(diff(FBM_2,2^j)^2)
      MSD_data_1 <- append(MSD_data_1,MSD_1)
      MSD_data_2 <- append(MSD_data_2,MSD_2)
    }
    Linear_Model_1<-lm(log(MSD_data_1 ,base=2)~c(j1:j2))
    Linear_Model_2<-lm(log(MSD_data_2 ,base=2)~c(j1:j2))
    print(r)
    regression_coefficient_avg_1 <- regression_coefficient_avg_1 + summary(Linear_Model_1)$coefficients[2,1]
    regression_coefficient_avg_2 <- regression_coefficient_avg_2 + summary(Linear_Model_2)$coefficients[2,1]
  }
  
  data_MSD_1 <- append(data_MSD_1,regression_coefficient_avg_1/runs)
  data_MSD_2 <- append(data_MSD_2,regression_coefficient_avg_2/runs)
  j1 <- j1 + 1
  j2 <- j2 + 1
}
data_MSD_1 <- (data_MSD_1)*0.5
data_MSD_2 <- (data_MSD_2)*0.5
 
par(mfrow=c(2,1))

plot(c(min_level:max_level),data_MSD_1 , type = "l"
     , xlab = "path size"
     , ylab = "angular coefficent"
     , main = paste(" regression coefficients for logMSD vs Path size, Hurst = ", Hurst_1))
plot(c(min_level:max_level),data_MSD_2, type = "l"
     , xlab = "path size"
     , ylab = "angular coefficent"
     , main = paste("regression coefficients for logMSD vs Path size, Hurst = ", Hurst_2))
#-----------------Regression -------------------------


Hurst_1 = 0.25
Hurst_2 = 0.75
max_level = 17
min_level = 11

data_1 <- c()
data_2 <- c()
runs = 10

j1 <- 5
j2 <- 7
seedcounter <-1
for(level in min_level:max_level){
  avg_delta_1 <- 0
  avg_delta_2 <- 0
  l = j2-j1+1
  X <- matrix(c(c(j1:j2),rep(1,l)),2,l,byrow=TRUE)
  weights <- ginv(X)%*%c(1,0)
  #null_space <- Null(t(X))
  for(r in 1:runs){
    #set.seed(seedcounter)
    wavelet_eigen_1 <- low_dim_wavelet_sampe_covariances(level,c(j1:j2),Hurst_1)
    wavelet_eigen_2 <- low_dim_wavelet_sampe_covariances(level,c(j1:j2),Hurst_2)
   # seedcounter <- seedcounter + 1
    delta_1 <- 0
    delta_2 <- 0
    for(i in 1:l){
      delta_1<- delta_1 + weights[i]*log(wavelet_eigen_1[[i]],base=2)
      delta_2<- delta_2 + weights[i]*log(wavelet_eigen_2[[i]],base=2)
    }
    avg_delta_1 <-avg_delta_1+delta_1
    avg_delta_2 <-avg_delta_2+delta_2
  }
  data_1 <- append(data_1,avg_delta_1)
  data_2 <- append(data_2,avg_delta_2)
  j1 <- j1 + 1
  j2 <- j2 + 1
}
data_1 <- data_1/runs
data_2 <- data_2/runs
data_rescale_1 <- (data_1 - 1)*0.5
data_rescale_2 <- (data_2 - 1)*0.5

par(mfrow=c(2,1))

plot(c(min_level:max_level),data_rescale_1, type = "l"
     , xlab = "path size"
     , ylab = "delta"
     , main = paste("rescaled Delta Estimator vs Path size, Hurst = ", Hurst_1))
plot(c(min_level:max_level),data_rescale_2, type = "l"
     , xlab = "path size"
     , ylab = "delta"
     , main = paste("rescaled Delta Estimator vs Path size, Hurst = ", Hurst_2))


