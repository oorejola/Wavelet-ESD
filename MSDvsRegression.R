# Oliver Orejola
# Created: 9/27/21
# 
#------------------------- [ Libraries ]----------------------------
library(somebm)
library(wavelets)
library(diptest)
library(MASS)
#------------------------- [ Functions ]----------------------------
coordinate_matrix <- function(n){
  mat <- c()
  for(i in 1:n){
    x <- rnorm(n)
    col <- x/sqrt(sum(x^2)) 
    mat <- append(mat,col)
  }
  return(matrix(mat, n, n,byrow = FALSE))
}

low_dim_wavelet_sampe_covariances<- function(level,scales,Hursts, mixed = FALSE){
  N = 2^level #Path size
  #n_j = N/(2^scale)
  p = length(Hursts)
  P <- coordinate_matrix(p)
  wavelet_list <- list()
  for(j in scales){
    wavelet_list <- append(wavelet_list, c(NA))
  }
  for(H in Hursts){
    fractional_brownian <-  N^H*fbm(hurst = H, n = N) 
    wavelet_transform <- dwt(fractional_brownian, filter = "d2", n.levels = level, boundary = "reflection")
    i = 1
    for(j in scales){  
      wavelet_list[[i]] <- append(wavelet_list[[i]] ,unlist(wavelet_transform@W[j]))
      i <- i+1
    }
  }
  # Remove NA generated by initiation of list of blank vectors
  for(i in 1:length(wavelet_list)){
    wavelet_list[[i]] <-wavelet_list[[i]][!is.na(wavelet_list[[i]])]
  }
  
  i=1
  for(j in scales){
    effective_sample_size = N/(2^j) #
    wavelet_mat <- matrix(wavelet_list[[i]], effective_sample_size, p,byrow = FALSE)  # convert vectors into matrices 
    if(mixed == TRUE){ 
      mixed_wavlet_mat <- wavelet_mat %*% t(P)
      mixed_wavlet_product <- crossprod(mixed_wavlet_mat)
      eigenvalues <- eigen(1/effective_sample_size *mixed_wavlet_product)$values #add list of eigenvalues
    }
    else{
      wavelet_product <-  crossprod(wavelet_mat)
      eigenvalues <- eigen(1/effective_sample_size *wavelet_product)$values
    }
    wavelet_list[[i]]  <- eigenvalues
    i=i+1
  }
  return(wavelet_list)
}



#------[ Simulations and Data generation ]----------

#---------- MEAN SQUARED DIFFERENCE 
levels = 11
pathsize = 2^levels
hurst = 0.25
scales <- c(4:6)
FBM <- pathsize^hurst*fbm(hurst, pathsize)
runs = 5000

data <- c()

regression_coefficient_avg <-0

for(r in 1:runs){
  MSD_data <- c()
  for(j in scales){
    MSD <- mean(diff(FBM,2^j)^2)
    MSD_data <- append(MSD_data,MSD)
  }
  Linear_Model<-lm(log(MSD_data ,base=2)~scales)
  regression_coefficient_avg <- regression_coefficient_avg + summary(Linear_Model)$coefficients[2,1]
}
regression_coefficient_avg/runs
#-----------------Regression -------------------------
j1 <- 5
j2 <- 8
l = j2-j1+1
c(c(j1:j2),rep(1,l))
X <- matrix(c(c(j1:j2),rep(1,l)),2,l,byrow=TRUE)
X
null_space <- Null(t(X))
weights <- ginv(X)%*%c(1,0)
weights 

Hurst = 0.25
level = 16

delta <- 0
data <- c()
runs = 100

for(level in 11:level){
  avg_delta <- 0
  for(r in 1:runs){
    wavelet_eigen <- low_dim_wavelet_sampe_covariances(level,c(j1:j2),Hurst)
    delta <- 0
    for(i in 1:l){
      delta<- delta + weights[i]*log(wavelet_eigen[[i]],base=2)
    }
    avg_delta <-avg_delta+delta
  }
  data <- append(data,avg_delta)
}
data <- data/runs

data_rescale <- (data - 1)*0.5
#data75<-data
#data05 <-data
data25 <-data_rescale 
par(mfrow=c(1,1))

plot(c(11:level),data25, type = "l"
     , xlab = "path size"
     , ylab = "delta"
     , main = "Def 3.2 vs path size. Hurst = 0.25, j1 = 5 j2 = 8")
plot(c(11:level),data05, type = "l"
     , xlab = "path size"
     , ylab = "delta"
     , main = "Def 3.2 vs path size. Hurst = 0.50, j1 = 6 j2 = 11")
plot(c(11:level),data75, type = "l"
     , xlab = "path size"
     , ylab = "delta"
     , main = "Def 3.2 vs path size. Hurst = 0.75, j1 = 6 j2 = 11")
